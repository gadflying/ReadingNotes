######理想的设计特征  
* 最小的复杂度(kiss)  
* 易于维护(不解释)  
* 松散耦合(合理抽象与封装)  
* 可扩展性(考虑到将来可能的改变)  
* 可重用性(不解释)  
* 高扇入(大量的类使用某个特定的类)  
* 低扇出(一个类里适量使用其他类)  
* 可移植性(不解释)  
* 精简性(不要有多余的功能代码)  
* 层次性(代码逻辑分层抽象)  
* 标准技术 (慎用乱七八糟的框架或技术，你爽了，别人还怎么玩？)

######类的定义
类是由一组数据和子程序构成的集合。这些数据和子程序共同拥有一组内聚的、明确定义的职责。类也可以是由一组子程序构成的集合，这些子程序提供一组内聚的服务，哪怕其中并未涉及公用的数据。

######使用抽象数据类型（`Abstract Data Types`简称`ADT`）的益处

* 可以隐藏实现细节
* 改动不会影响到整个程序
* 让接口能提供更多信息
* 更容易提高性能
* 让程序的正确性更显而易见
* 程序更具自我说明性
* 无须在程序内到处传递数据
* 可以像在现实世界中那样操作实体，而不用在底层实现上操作它

######良好的类接口

* 良好的抽象
 * 类的接口应该展现一致的抽象层次
 * 一定要理解类所实现的抽象是什么
 * 提供成对的服务
 * 把不相关的信息转移到其他类中
 * 尽可能让接口可编程，而不是表达语义
 * 谨防在修改时破坏接口的抽象
 * 不要添加与接口抽象不一致的公用成员
 * 同时考虑抽象性和内聚性
* 良好的封装
 * 尽可能的限制类和成员的可访问性
 * 不要公开暴露成员数据
 * 避免把私有的实现细节放入类的接口中
 * 不要对类的使用者做出任何假设
 * 避免使用友元类（`friend class`）
 * 不要因为一个子程序里仅使用公用子程序，就把它归入公开接口
 * 让阅读代码比编写代码更方便
 * 要格外警惕从语义上破坏封装性
 * 留意过于紧密的耦合关系

######有关设计和实现的问题

* 包含（“有一个……”的关系）
 * 通过包含来实现“有一个”的关系
 * 在万不得已时通过`private`继承来实现“有一个”的关系
 * 警惕有超过约`7`个数据成员的类
* 继承（“是一个……”的关系）
 * 用`public`继承来实现“是一个”的关系
 * 要么使用继承并进行详细说明，要么就不要用它
 * 遵循`Liskov`替换原则（`Liskov Substitution Principle, LSP`）
 * 确保只继承需要继承的部分
 * 不要“覆盖”一个不可覆盖的成员函数
 * 把公共的接口、数据及操作放到继承树中尽可能高的位置
 * 只有一个实例的类是值得怀疑的（单例除外）
 * 只有一个派生类的基类也值得怀疑
 * 派生后覆盖了某个子程序，但在其中没有做任何操作，这种情况也值得怀疑
 * 避免让继承体系过深
 * 尽量使用多态，避免大量的类型检查
 * 让所有数据都是`private`（而非`protected`）
* 继承的规则
 * 如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象
 * 如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序
 * 如果多个类既共享数据也共享行为，应该让它们从一个共同的基类继承而来，并在基类里定义共用的数据个子程序
 * 当你想由基类控制接口时，使用继承；当你想自己控制接口时，使用包含

######成员函数和数据成员

* 让类中子程序的数量尽可能少
* 禁止隐式的产生你不需要的成员函数和运算符
* 减少类所调用的不同子程序的数量
* 对其他类的子程序的间接调用要尽可能少
* 一般来说，应尽量减小类和类之间相互合作的范围（尽量让下面几个数字最小：）
 * 所实例化的对象的种类
 * 在被实例化对象上直接调用的不同子程序的数量
 * 调用由其他对象返回的对象的子程序的数量

######构造函数

* 如果可能，应该在所有的构造函数中初始化所有的数据成员
* 用私用构造函数来强制实现单件属性
* 优先采用深拷贝，除非论证可行，才采用浅拷贝
