#####第5章 软件构建中的设计
######理想的设计特征  

* 最小的复杂度(kiss)  
* 易于维护(不解释)  
* 松散耦合(合理抽象与封装)  
* 可扩展性(考虑到将来可能的改变)  
* 可重用性(不解释)  
* 高扇入(大量的类使用某个特定的类)  
* 低扇出(一个类里适量使用其他类)  
* 可移植性(不解释)  
* 精简性(不要有多余的功能代码)  
* 层次性(代码逻辑分层抽象)  
* 标准技术 (慎用乱七八糟的框架或技术，你爽了，别人还怎么玩？)

#####第6章 可以工作的类
######类的定义

类是由一组数据和子程序构成的集合。这些数据和子程序共同拥有一组内聚的、明确定义的职责。类也可以是由一组子程序构成的集合，这些子程序提供一组内聚的服务，哪怕其中并未涉及公用的数据。

######使用抽象数据类型（`Abstract Data Types`简称`ADT`）的益处

* 可以隐藏实现细节
* 改动不会影响到整个程序
* 让接口能提供更多信息
* 更容易提高性能
* 让程序的正确性更显而易见
* 程序更具自我说明性
* 无须在程序内到处传递数据
* 可以像在现实世界中那样操作实体，而不用在底层实现上操作它

######良好的类接口

* 良好的抽象
 * 类的接口应该展现一致的抽象层次
 * 一定要理解类所实现的抽象是什么
 * 提供成对的服务
 * 把不相关的信息转移到其他类中
 * 尽可能让接口可编程，而不是表达语义
 * 谨防在修改时破坏接口的抽象
 * 不要添加与接口抽象不一致的公用成员
 * 同时考虑抽象性和内聚性
* 良好的封装
 * 尽可能的限制类和成员的可访问性
 * 不要公开暴露成员数据
 * 避免把私有的实现细节放入类的接口中
 * 不要对类的使用者做出任何假设
 * 避免使用友元类（`friend class`）
 * 不要因为一个子程序里仅使用公用子程序，就把它归入公开接口
 * 让阅读代码比编写代码更方便
 * 要格外警惕从语义上破坏封装性
 * 留意过于紧密的耦合关系

######有关设计和实现的问题

* 包含（“有一个……”的关系）
 * 通过包含来实现“有一个”的关系
 * 在万不得已时通过`private`继承来实现“有一个”的关系
 * 警惕有超过约`7`个数据成员的类
* 继承（“是一个……”的关系）
 * 用`public`继承来实现“是一个”的关系
 * 要么使用继承并进行详细说明，要么就不要用它
 * 遵循`Liskov`替换原则（`Liskov Substitution Principle, LSP`）
 * 确保只继承需要继承的部分
 * 不要“覆盖”一个不可覆盖的成员函数
 * 把公共的接口、数据及操作放到继承树中尽可能高的位置
 * 只有一个实例的类是值得怀疑的（单例除外）
 * 只有一个派生类的基类也值得怀疑
 * 派生后覆盖了某个子程序，但在其中没有做任何操作，这种情况也值得怀疑
 * 避免让继承体系过深
 * 尽量使用多态，避免大量的类型检查
 * 让所有数据都是`private`（而非`protected`）
* 继承的规则
 * 如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象
 * 如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序
 * 如果多个类既共享数据也共享行为，应该让它们从一个共同的基类继承而来，并在基类里定义共用的数据个子程序
 * 当你想由基类控制接口时，使用继承；当你想自己控制接口时，使用包含

######成员函数和数据成员

* 让类中子程序的数量尽可能少
* 禁止隐式的产生你不需要的成员函数和运算符
* 减少类所调用的不同子程序的数量
* 对其他类的子程序的间接调用要尽可能少
* 一般来说，应尽量减小类和类之间相互合作的范围（尽量让下面几个数字最小：）
 * 所实例化的对象的种类
 * 在被实例化对象上直接调用的不同子程序的数量
 * 调用由其他对象返回的对象的子程序的数量

######构造函数

* 如果可能，应该在所有的构造函数中初始化所有的数据成员
* 用私用构造函数来强制实现单件属性
* 优先采用深拷贝，除非论证可行，才采用浅拷贝

######创建类的理由

* 对现实世界中的对象建模
* 对抽象对象建模
* 降低复杂度
* 隔壁复杂度
* 隐藏实现细节
* 限制变化所影响的范围
* 隐藏全局数据
* 让参数传递更顺畅
* 创建中心控制点
* 让代码更易于重用
* 为程序族做计划
* 把相关操作放到一起
* 实现特定的重构

######应该避免的类

* 避免创建万能类
* 消除无关紧要的类
* 避免用动词命名的类

######类的质量核对表

* 抽象数据类型
 * 是否把程序中的类都看做是抽象数据类型了？是否从这个角度评估它们的接口了？
* 抽象
 * 类是否有一个中心目的？
 * 类的命名是否恰当？其名字是否表达了其中心目的？
 * 类的接口是否展现了一致的抽象？
 * 类的接口是否能让人清楚明白的知道该如何使用它？
 * 类的接口是否足够抽象，使你能不必顾虑它是如何实现其服务的？能把类看做黑盒子吗？
 * 类提供的服务是否足够完整，能让其他类无须动用其内部数据？
 * 是否已从类中除去无关信息？
 * 是否考虑过把类进一步分解为组件类？是否已尽可能将其分解？
 * 在修改类时是否维持了其接口的完整性？
* 封装
 * 是否把类的成员的可访问性降到最小？
 * 是否避免暴露类中的数据成员？
 * 在编程语言所许可的范围内，类是否已尽可能的对其他的类隐藏了自己的实现细节？
 * 类是否避免对其使用者，包括其派生类会如何使用它做了假设？
 * 类是否不依赖于其他类？它是松散耦合的吗？
* 继承
 * 继承是否只用来建立“是一个”的关系？也就是说，派生类是否遵循了`LSP`？
 * 类的文档中是否记述了其继承策略？
 * 派生类是否避免了“覆盖”不可覆盖的方法？
 * 是否把公用的接口、数据和行为都放到尽可能高的继承层次中了？
 * 继承层次是否很浅？
 * 基类中所有的数据成员是否都被定义为`private`而非`protected`的了？
* 跟实现相关的其它问题
 * 类中是否只有大约七个或更少的数据成员？
 * 是否把类直接或间接调用其他类的子程序的数量减到最少了？
 * 类是否只在绝对必要时才与其他的类相互协作？
 * 是否在构造函数中初始化了所有的数据成员？
 * 除非拥有经过测量的、创建浅层复本的理由，类是否都被设计为当做深层复本使用？
* 与语言相关的问题
 * 你是否研究过所用编程语言里和类相关的各种特有问题？

#####第7章 高质量的子程序
######创建子程序的理由

* 降低复杂度
* 引入中间、易懂的抽象
* 避免代码重复
* 支持子类化（`subclassing`）
* 隐藏顺序
* 隐藏指针操作
* 提高可移植性
* 简化复杂的布尔判断
* 改善性能
* 隔离复杂度
* 隐藏实现细节
* 限制变化所带来的影响
* 隐藏全局数据
* 形成中央控制点
* 促成可重用的代码
* 达到特定的重构目的

######好的子程序名字

* 描述子程序所做的所有事情
* 避免使用无意义的、模糊或表述不清的动词
* 不要仅通过数字来形成不同的子程序名字
* 根据需要确定子程序名字的长度
* 给函数命名时要对返回值有所描述
* 给过程起名时使用语气强烈的动词加宾语的形式
* 准确使用对仗词
* 为常用操作确立命名规则

######高质量的子程序核对表

* 大局事项
 * 创建子程序的理由充分吗？
 * 一个子程序中所有适合单独提出的部分是不是已经被提出到单独的子程序中了？
 * 过程的名字中是否用了强烈、清晰的“动词＋宾语”词组？函数的名字是否描述了其返回值？
 * 子程序的名字是否描述了它所做的全部事情？
 * 是否给常用的操作建立了命名规则？
 * 子程序是否具有强烈的功能上的内聚性？即它是否做且只做一件事，并且把它做的很好？
 * 子程序之间是否有较松的耦合？子程序与其他子程序之间的连接是否是小的（`small`）、明确的（`intimate`）、可见的（`visible`）和灵活的（`flexible`）？
 * 子程序的长度是否是由其功能和逻辑自然确定，而非遵循任何人为的编码标准？
* 参数传递事宜
 * 整体来看，子程序的参数表是否表现出一种具有整体性且一直的接口抽象？
 * 子程序参数的排列顺序是否合理？是否与类似的子程序的参数排列顺序相符？
 * 接口假定是否已在文档中说明？
 * 子程序的参数个数是否没超过`7`个？
 * 是否用到了每一个输入参数？
 * 是否用到了每一个输出参数？
 * 子程序是否避免了把输入参数当做工作变量？
 * 如果子程序是一个函数，那么它是否在所有可能的情况下都能返回一个合法的值？

######本章要点

* 创建子程序最主要的目的是提高程序的可管理性，当然也有其他一些好的理由。其中，节省代码空间只是一个次要原因；提高可读性、可靠性和可修改性等原因都更重要一些。
* 有时候，把一些简单的操作写成独立的子程序也非常有价值。
* 子程序可以按照其内聚性分为很多类，而你应该让大多数子程序具有功能上的内聚性，这是最佳的一种内聚性。
* 子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分，那就说明这个子程序设计的很差劲。如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。不管怎样，糟糕的名字都意味着程序需要修改。
* 只有在某个子程序的主要目的是返回由其名字所描述的特定结果时，才应该使用函数。
* 细心的程序员会非常谨慎的使用宏，而且只在万不得已时才用。

#####第8章 防御式编程 
######防御式编程的主要思想
子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般的说，其核心思想是要承认程序都会有问题，都需要被修改。

######使用断言的指导建议

* 用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况
* 避免把需要执行的代码放到断言中
* 用断言来注解并验证前条件和后条件
* 对于高健壮性的代码，应该先使用断言再处理错误

######错误处理技术

* 返回中立值
* 换用下一个正确的数据
* 返回与前次相同的数据
* 换用最接近的合法值
* 把警告信息记录到日志文件中
* 返回一个错误码
* 调用错误处理子程序或对象
* 当错误发生时显示出错消息
* 用最妥当的方式在局部处理错误
* 关闭程序

######健壮性与正确性

* 正确性意味着永远不返回不准确的结果，哪怕不返回结果也比返回不准确的结果好。然而，健壮性则意味着要不断尝试采取某些措施，以保证软件可以持续地运转下去，哪怕有时做出一些不够准确的结果
* 人身安全攸关的软件往往更倾向于正确性而非健壮性
* 消费类应用软件往往更注重健壮性而非正确性

######异常

* 用异常通知程序的其他部分，发生了不可忽略的错误
* 只在真正例外的情况下才抛出异常
* 不能用异常来推卸责任
* 避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们截获
* 在恰当的抽象层次抛出异常
* 在异常消息中加入关于导致异常发生的全部信息避免使用空的`catch`语句
* 了解所用函数库可能抛出的异常
* 考虑创建一个集中的异常报告机制
* 把项目中对异常的使用标准化
* 考虑异常的替换方案

######确定在产品代码中该保留多少防御式代码

* 保留那些检查重要错误的代码
* 去掉检查细微错误的代码
* 去掉可以导致程序硬性崩溃的代码
* 保留可以让程序稳妥地崩溃的代码
* 为你的技术支持人员记录错误信息
* 确认留在代码中的错误信息是友好的

######防御式编程核对表

* 一般事宜
 * 子程序是否保护自己免遭有害输入数据的破坏？
 * 你用断言来说明编程假定吗？其中包括了前条件和后条件吗？
 * 断言是否只是用来说明从不应该发生的情况？
 * 你是否在架构或高层设计中规定了一组特定的错误处理技术？
 * 你是否在架构或高层设计中规定了是让错误处理更趋向于健壮性还是正确性？
 * 你是否建立了隔栏来遏制错误可能造成的破坏？是否减少了其他需要关注错误处理的代码的数量？
 * 代码中用到辅助调试的代码了吗？
 * 如果需要启用或禁用添加的辅助助手的话，是否无须大动干戈？
 * 在防御式编程时引入的代码量是否适宜——既不过多，也不过少？
 * 你在开发阶段是否采用了进攻式编程来使错误难以被忽视？ 
* 异常
 * 你在项目中定义了一套标准化的异常处理方案吗？
 * 是否考虑过异常之外的其他代替方案？
 * 如果可能的话，是否在局部处理了错误而不是把它当成一个异常抛到外部？
 * 代码中是否避免了在构造函数和析构函数中抛出异常？
 * 所有的异常是否都与抛出它们的子程序处于同一抽象层次上？
 * 每个异常是否都包含了关于异常发生的所有背景信息？
 * 代码中是否没有使用空的`catch`语句？
* 安全事宜
 * 检查有害输入数据的代码是否也检查了故意的缓冲区溢出、`SQL`注入、`HTML`注入、整数溢出以及其他恶意输入数据？
 * 是否检查了所有的错误返回码？
 * 是否捕获了所有的异常？
 * 出错消息中是否避免出现有助于攻击者攻入系统所需的信息？

######本章要点

* 最终产品代码中对错误的处理方式要比“垃圾进，垃圾出”复杂的多
* 防御式编程技术可以让错误更容易发现、更容易修改，并减少错误对产品代码的破坏
* 断言可以帮助人尽早发现错误，尤其是在大型系统和高可靠性系统中，以及快速变化的代码中
* 关于如果处理错误输入的决策是一项关键的错误处理决策，也是一项关键的高层设计决策
* 异常提供了一种与代码正常流程角度不同的错误处理手段。如果留心使用异常，它可以成为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较
* 针对产品代码的限制并不使用于开发中的软件，你可以利用这一优势在开发中添加有助于更快地排查错误的代码

#####第9章 伪代码编写过程
######创建一个类的步骤

* 创建类的总体设计
* 创建类中的子程序
* 复审并测试整个类

######使用伪代码的指导原则

* 用自然语言来精确描述特定的操作
* 避免使用目标编程语言中的语法元素
* 在本意的层面上编写伪代码
* 在一个足够低的层次上编写伪代码，以便可以近乎自动的从它生成代码

######使用伪代码的好处

* 伪代码使得评审更容易
* 伪代码支持反复迭代精化的思想
* 伪代码使变更更加容易
* 伪代码能使给代码做注释的工作量减到最少
* 伪代码比其他形式的设计文档更容易维护

######通过伪代码编程过程创建子程序

* 设计子程序
 * 检查先决条件
 * 定义子程序要解决的问题
 * 为子程序命名
 * 决定如何测试子程序
 * 在标准库中搜索可用的功能
 * 考虑错误处理
 * 考虑效率问题
 * 研究算法和数据类型
 * 编写伪代码
 * 考虑数据
 * 检查伪代码
 * 在伪代码中实验一些想法，留下最好的想法（迭代）
* 编写子程序代码
 * 写出子程序的声明
 * 把伪代码转换为高层次的注释
 * 在每条注释下面填充代码
 * 检查代码是否需要进一步分解
* 检查代码
 * 在脑海里检查程序中的错误
 * 编译子程序
 * 在调试器中逐行执行代码
 * 测试代码
 * 消除程序中的错误
* 收尾工作
 * 检查子程序的接口，确认所有的输入、输出都参与了计算，并且所有的参数也都用到了
 * 检查整体的设计质量，确认只做一件事情、松耦合以及使用防御式设计
 * 检查子程序中的变量，检查是否存在不准确的变量名称、未被用到的对象、未经声明的变量以及未经正确初始化的对象
 * 检查子程序的语句和逻辑，是否有死循环、错误嵌套以及资源泄露
 * 检查子程序的布局，格式是否具有良好的风格
 * 检查子程序的文档，确定是否正确
 * 除去冗余的注释
* 根据需要重复以上步骤

######伪代码编程过程的替代方案

* 测试先行开发
* 重构
* 契约式设计
* 东拼西凑

######伪代码编程过程核对表

* 是否检查过已满足所有的先决条件？
* 定义好这个类要解决的问题了吗？
* 高层次的设计是否足够清晰？能给这个类和其中的每一个子程序起一个好的名字吗？
* 考虑过改如何测试这个类及其中的每一个子程序了吗？
* 关于效率的问题，你主要从稳定的接口和可读的实现这两个角度考虑吗？还是主要从满足资源和速度的预期目标的角度考虑过呢？
* 在标准函数库或其他代码库中寻找过可用的子程序或组件了吗？
* 在参考书籍中查找过有用的算法了吗？
* 是否用详尽的伪代码设计好每一个子程序？
* 你在脑海里检查过伪代码吗？这些伪代码容易理解吗？
* 关注过那些可能会让你重返设计的警告信息了吗？
* 是否把伪代码正确的翻译成代码了？
* 你反复使用伪代码编程过程了吗？有没有根据需要把一些子程序拆分成更小的子程序？
* 在做出假定的时候有没有对它们加以说明？
* 已经删除掉那些冗余的注释了吗？
* 你是否采取了几次迭代中最好的那个结果？还是在一次迭代之后就停止了？
* 你完全理解你的代码了吗？这些代码是否容易理解？

######本章要点

* 创建类和子程序通常都是一个迭代的过程，在创建子程序的过程中获得的认识常常会反过来影响类的设计
* 编写好的伪代码需要使用易懂的自然语言，要避免使用特定编程语言才有的特性，同时要在意图的层面上写伪代码（要做什么，而不是怎么做）
* 伪代码编程过程是一个行之有效的做详细设计的工具，它同时让编码工作更容易。伪代码会直接转化为注释，从而确保了注释的准确性和实用性
* 不要只停留在你所想到的第一个设计方案上，反复使用伪代码做出多种方案，然后选出其中最佳的一种方案再开始编码
* 每一步完成后都要检查你的工作成果，还要鼓励其他人帮你来检查。这样你就会在投入精力最少的时候，用最低的成本发现错误
