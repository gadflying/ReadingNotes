####第一部分 `HTTP：Web`的基础
#####第1章 `HTTP`概述
######`URI`和`URL`

* `URI（Uniform Resource Identifier`）统一资源标识符，在世界范围内唯一标识并定位信息资源。`URI`有两种形式，分别称为`URL`和`URN`
* `URL` 统一资源定位符，描述了一台特定服务器上某资源的特定位置，现在几乎所有`URI`都是`URL`
* `URN` 统一资源名，作为特定内容的唯一名称使用，与目前的资源所在地无关（仍处于试验阶段）

######常见`HTTP`方法

* `GET` 从服务器向客户端发送命名资源
* `PUT` 将来自客户端的数据存储到一个命名的服务器资源中去
* `DELETE` 从服务器中删除命名资源
* `POST` 将客户端数据发送到一个服务器网关应用程序
* `HEAD` 仅发送命名资源响应中的`HTTP`首部

#####第2章 `URL`与资源
######`URL`组成

* `URL`的第一部分（`http`）是`URL`方案（`scheme`），方案可以告知`Web`客户端怎样访问资源
* `URL`的第二部分（`www.xxx.com`）指的是服务器位置，这部分告知`Web`客户端资源位于何处
* `URL`的第三部分（`/xxx/xxx.html`）是资源路径，路径说明了请求的是服务器上哪个特定的本地资源

######`URL`的语法  
`<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`

#####第3章 `HTTP`报文 
######报文的组成部分

* 对报文进行描述的起始行（`start line`）
* 包含属性的首部（`header`）块
* 可选的、包含数据的主体（`body`）部分

######报文的语法

* 请求报文的格式  
  `<method> <request url> <version>`  
  `<headers>`  
  `<entity-body>`
* 响应报文的格式（只有起始行的语法有所不同）  
  `<version> <status> <reason-phrase>`  
  `<headers>`  
  `<entity-body>`

######状态码

* `100~199` 信息性状态码
 * `100 Continue` 说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务端在收到请求之后必须进行响应
 * `101 Switching Protocols` 说明服务器正在根据客户端的指定，将协议切换成`Update`首部所列的协议
* `200~299` 成功状态码
 * `200 OK` 请求没问题，实体的主体部分包含了所请求的资源
 * `201 Created` 用于创建服务器对象的请求，响应的实体主体部分中应该包含各种引用了已创建的资源的`URL`，`location`首部包含的则是最具体的引用
 * `202 Accepted` 请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求
 * `203 Non-Authoritative Infomation` 实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本
 * `204 No Content` 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新
 * `205 Reset Content` 另一个主要用于浏览器的代码，负责告知浏览器清除当前页面中的所有`HTML`表单元素
 * `206 Partial Content` 成功执行了一个部分或`Range（范围）`请求，`206`响应中必须包含`Content-Range`、`Date`以及`ETag`或`Content-Location`首部
* `300~399` 重定向状态码
 * `300 Multiple Choices` 客户端请求一个实际指向多个资源的`URL`时会返回此状态码，返回时会带有一个选项列表供用户选择
 * `301 Moved Permanently` 在请求的`URL`已被移除时使用，响应的`Location`首部中应该包含资源现在所处的`URL`
 * `302 Found` 与`301`类似，但客户端应该使用`Location`首部给出的`URL`来临时定位资源，将来的请求仍应使用老的`URL`
 * `303 See Other` 告知客户端应该使用另一个`URL`来获取资源，新的`URL`位于响应报文的`Location`首部，主要目的是允许`POST`请求的响应将客户端定位到某个资源上去
 * `304 Not Modified` 客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起了一个条件`GET`请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改
 * `305 Use Proxy` 用来说明必须通过一个代理来访问资源，代理的位置由`Location`首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误的让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞
 * `306 (未使用)` 当前未使用
 * `307 Temporary Redirect` 与`301`类似，但客户端应该使用`Location`首部给出的`URL`来临时定位资源，将来的请求仍应使用老的`URL`
* `400~499` 客户端错误状态码
 * `400 Bad Request` 用于告知客户端它发送了一个错误的请求
 * `401 Unauthorized` 与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证
 * `402 Payment Required` 现在这个状态码还未使用，但已经被保留，以作未来之用
 * `403 Forbidden` 用来说明请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可以包 含实体的主体部分来对原因进行描述，但这个状态码通常是在服务器不想说明拒绝原因的时候使用的
 * `404 Not Found` 用于说明服务器无法找到所请求的`URL`，通常会包含一个实体，以便客户端应用程序显示给用户看
 * `405 Method Not Allowed` 发起的请求中带有所请求的`URL`不支持的方法时，使用此状态码。应该在响应中包含`Allow`首部，以告知客户端对所请求的资源可以使用哪些方法
 * `406 Not Acceptable` 客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的`URL`相匹配的资源时，使用此代码。通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足
 * `407 Proxy Authentication Required` 与`401`类似，但用于要求对资源进行认证的代理服务器
 * `408 Request Timeout` 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同有所不同，但通常对所有的合法请求来说都是够长的
 * `409 Conflict` 用于说明请求可能在资源上引发一些冲突。服务器担心请求会引发冲突时，可以发送此状态码，响应中应该包含描述冲突的主体
 * `410 Gone` 与`404`类似，只是服务器曾经拥有过此资源。主要用于`Web`站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了
 * `411 Length Required` 服务器要求在请求报文中包含`Content- Length`首部时使用
 * `412 Precondition Failed` 客户端发起了条件请求，且其中一个条件失败了的时候使用。客户端包含了`Expect`首部时发起的就是条件请求
 * `413 Request Entity Too Large` 客户端发送的实体主体部分比服务器能够或者希望处理的要大时使用
 * `414 Requets URL Too Long` 客户端所发请求中的请求`URL`比服务器能够或者希望处理的要长时使用
 * `415 Unsupported Media Type` 服务器无法理解或无法支持客户端所发实体的内容类型时使用
 * `416 Requested Range Not Satisfiable` 请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时使用
 * `417 Expectation Failed` 请求的`Expect`请求首部包含了一个期望，但服务器无法满足此期望时使用
* `500~599` 服务器错误状态码
 * `500 Internal Server Error` 服务器遇到一个妨碍它为请求提供服务的错误时使用
 * `501 Not Implemented` 客户端发起的请求超出服务器的能力范围时使用（比如使用了服务器不支持的请求方法）
 * `502 Bad Gateway` 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应时使用
 * `503 Service Unavailable` 用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器知道什么时候资源会变成可用的，可以在响应中包含一个`Retry-After`首部
 * `504 Gateway Timeout` 与`408`类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了
 * `505 HTTP Version Not Supported` 服务器收到的请求使用了它无法或不愿支持的协议版本时使用·

######首部

* 通用首部：客户端和服务器都可以使用的通用首部
* 请求首部：请求报文特有
 * `Accept`首部
 * 条件请求首部
 * 安全请求首部
 * 代理请求首部
* 响应首部：响应报文特有
 * 协商首部
 * 安全响应首部
* 实体首部：用于应对实体主体部分的首部
 * 内容首部
 * 实体缓存首部
* 扩展首部：非标准首部，由应用程序开发者创建

#####第4章 连接管理
######`Connection`首部处理

* `HTTP`应用程序收到一条带有`Connection`首部的报文时， 接收端会解析发送端请求的所有选项，并将其应用。然后会在将此报文转发给下一跳地址之前，删除`Connection`首部以及`Connection`中列出的所有首部。而且，可能还会有少量没有作为`Connection`首部值列出，但一定不能被代理转发的逐跳首部。其中包括`Proxy-Authenticate`、`Proxy-Connection`、`Transfer-Encoding`和`Upgrade`

######`Keep-Alive`连接的限制和规则

* 在`HTTP/1.0`中，`Keep-Alive`并不是默认使用的。客户端必须发送一个`Connection : Keep-Alive`请求首部来激活`Keep-Alive`连接
* `Connection : Keep-Alive`首部必须随所有希望保持持久连接的报文一起发送。如果客户端没有发送`Connection : Keep-Alive`首部，服务器就会在那条请求之后关闭连接
* 通过检测响应中是否包含`Connection : Keep-Alive`响应首部，客户端可以判断服务器是否会在发出响应之后关闭连接
* 只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态。也就是说实体的主体部分必须有正确的`Content-Length`，在一条`Keep-Alive`信道中回送错误的`Content-Length`是很糟糕的事情，这样事务处理的另一端就无法精确的检测出一条报文的结束和另一条报文的开始
* 代理和网关必须执行`Connection`首部的规则，必须在将报文转发出去或将其高速缓存之前，删除在`Connection`首部中命名的所有首部字段以及`Connection`首部自身
* 严格来说，不应该与无法确定是否支持`Connection`首部的代理服务器建立`Keep-Alive`连接，以防出现哑代理问题
* 从技术上来说，应该忽略所有来自`HTTP/1.0`设备的`Connection`首部字段（包括`Connection : Keep-Alive`），因为它们可能是由比较老的代理服务器误转发的
* 除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备

######持久连接的限制和规则

* 发送了`Connection : close`请求首部之后，客户端就无法在那条连接上发送更多的请求了
* 如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个`Connection : close`请求首部
* 只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主体部分的长度都和响应的`Content-Length`一致，或是用分块传输编码方式编码的——连接才会持久保持
* `HTTP/1.1`的代理必须能够分别管理与客户端和服务器的持久连接——每个持久连接都只适用于一跳传输
* （由于较老的代理会转发`Connection`首部，所以）`HTTP/1.1`的代理服务器不应该与`HTTP/1.0`客户端建立持久连接，除非它们了解客户端的处理能力（比较扯淡）
* 尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管`Connection`首部取了什么值，`HTTP/1.1`设备都可以在任意时刻关闭连接
* `HTTP/1.1`应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累积起来的副作用，客户端都应该重试这条请求
* 除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求
* 一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信，所以如果有`N`个用户试图访问服务器的话，代理最多要维持`2N`条到任意服务器或父代理的连接

######管道化连接的几条限制

* 如果`HTTP`客户端无法确认连接是持久的，就不应该使用管道
* 必须按照与请求相同的顺序回送`HTTP`响应。`HTTP`报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了
* `HTTP`客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求
* `HTTP`客户端不应该用管道化的方式发送会产生副作用的请求（比如`POST`）。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全的重试`POST`这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险

######幂等请求

* 如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是幂等的。

####第二部分 `HTTP`结构
#####第5章 `Web`服务器
######`Web`服务器任务基本流程

* 建立连接——接收一个客户端连接，或者如果不希望与这个客户端建立连接，就将其关闭
* 接收请求——从网络中读取一条`HTTP`请求报文
* 处理请求——对请求报文进行解释，并采取行动
* 访问资源——访问报文中指定的资源
* 构建响应——创建带有正确首部的`HTTP`响应报文
* 发送响应——将响应回送给客户端
* 记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中

#####第6章 代理
######代理的常见使用

* 儿童过滤器
* 文档访问控制
* 安全防火墙
* `Web`缓存
* 反向代理
* 内容路由器
* 转码器
* 匿名访问

######客户端流量流向代理的方法

* 修改客户端（手动设置）
* 修改网络（拦截网络流量）
* 修改`DNS`的命名空间（手动或动态修改`DNS`名称列表）
* 修改`Web`服务器（向客户端发送`HTTP`重定向命令）

#####第7章 缓存
######缓存的优点

* 减少了冗余的数据传输
* 缓解了网络瓶颈问题
* 降低了对原始服务器的要求
* 减低了距离延时

######缓存再验证规则

* 缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求，最常用的是在请求中加入`If-Modified-Since`首部
* 如果内容没有变化（再验证命中），服务器会以一个小的`304 Not Modified`进行响应
* 如果服务器对象与已缓存副本不同（再验证未命中），服务器会发送一条普通的、带有完整内容的`HTTP 200 OK`响应
* 如果服务器对象已经被删除了（对象被删除），服务器会回送`404 Not Found`，缓存也会将其副本删除

######缓存的处理步骤

* 接收——缓存从网络中读取抵达的请求报文
* 解析——缓存对报文进行解析，提取出`URL`和各种首部
* 查询——缓存查看是否有本地副本可用，如果没有就获取一份副本并保存在本地
* 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是就询问服务器是否有任何更新
* 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文
* 发送——缓存通过网络将响应发回客户端
* 日志——缓存可选的创建一个日志文件条目来描述这个事务

######在响应首部中控制缓存时间的方法：（按优先级递减）

* `Cache-Control : no-store`（不缓存）
* `Cache-Control : no-cache`（可以缓存，但是必须先验证才能提供给客户端）
* `Cache-Control : must-revalidate`（可以缓存，但是必须先验证才能提供给客户端）
* `Cache-Control : max-age`（缓存有效时间）
* `Expires`（缓存过期日期，不建议使用，因为服务器时间不一定同步）
* 不添加，让缓存确定自己的过期日期

#####第8章 集成点：网关、隧道及中继
######网关的概念

* 网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法
* 网关是资源和应用程序之间的粘合剂
* 应用程序可以（通过`HTTP`或其他已定义的接口）请求网关来处理某条请求，网关可以提供一条响应
* 网关可以向数据库发起查询语句，或是生成动态的内容，就像一个门一样：进去一条请求，出来一个响应

######协议网关

* `HTTP/*`：服务器端`Web`网关
* `HTTP/HTTPS`：服务器端安全网关
* `HTTPS/HTTP`：客户端安全加速器网关

######资源网关

* `CGI`（通用网关接口 `Common Gateway Interface`）
* 服务器扩展`API`

######隧道

* 用`CONNECT`建立`HTTP`隧道
* 数据隧道、定时及连接管理
* `SSL`隧道

######中继

* `HTTP`中继是没有完全遵循`HTTP`规范的简单`HTTP`代理
* 中继负责处理`HTTP`中建立连接的部分，然后对字节进行盲转发
* 中继无法正确处理`Connection`首部，所以有潜在的挂起`keep-alive`连接的可能

#####第9章 `Web`机器人
######爬虫及其爬行方式

* `Web`爬虫是一种机器人，它们会递归的对各种信息性`Web`站点进行遍历
* 爬虫需要一个根集，一个好的根集会包括一些大的流行站点
* 爬虫需要对`HTML`页面进行解析，提取出`URL`链接并将相对`URL`转化为绝对形式
* 避免循环常用的技术：
 * 树和散列表
 * 有损的存在位图
 * 检查点（储存爬过的链接）
 * 分类
 * 规范化`URL`
 * 广度优先的爬行
 * 节流（限制从同一个站点爬取的数量）
 * 限制`URL`大小
 * `URL`/站点黑名单
 * 模式检测（避免无限重复循环）
 * 内容指纹
 * 人工监视

#####第10章 `HTTP-NG`
######模块化及功能增强

* 第一层，报文传输层（`message transport layer`）。这一层不考虑报文的功能，而是致力于端点间报文的不透明传输
* 第二层，远程调用层（`remote invocation layer`）。定义了请求/响应的功能，客户端可以通过这些功能调用对服务器资源的操作，本层独立于报文的传输以及操作的精确语义，它只是提供了一种标准的方法来调用服务器上所有的操作
* 第三层，`Web`应用层（`Web application layer`）。提供了大部分的内容管理逻辑，还支持其他构建在远程调用基础上的服务

####第三部分 识别、认证与安全
#####第11章 客户端识别与`cookie`机制
######承载用户身份信息的`HTTP`首部

* `From`：用户的`E-mail`地址
* `User-Agent`：用户的浏览器软件
* `Referer`：用户是从这个页面上依照链接跳转过来的
* `Authorization`：用户名和密码
* `Client-IP`：客户端的`IP`地址
* `X-Forwarded-For`：客户端的`IP`地址
* `Cookie`：服务器产生的`ID`标签

######使用客户端`IP`地址的缺点

* 客户端`IP`地址描述的是所用的机器，而不是用户。如果多个用户共享一台计算机，就无法对其进行区分了
* 很多因特网服务提供商会在用户登录时为其动态分配`IP`地址
* 很多用户是通过防火墙来浏览网络内容的，防火墙隐藏了客户端的实际`IP`地址
* 如果使用了代理服务器，可能得到的会是代理服务器的`IP`地址

######用户登录

* 如果服务器希望在为用户提供对站点的访问之前，先行登录，可以向浏览器回送一条`HTTP`响应代码`401 Login Required`。然后浏览器会显示一个登录对话框，并用`Authorization`首部在下一条对服务器的请求中提供这些信息

######胖`URL`

* 有些`Web`站点会为每个用户生成特定版本的`URL`来追踪用户的身份，改动后包含了用户信息的`URL`被成为胖`URL`
* 胖`URL`的问题
 * 丑陋的`URL`
 * 无法共享
 * 破坏缓存
 * 额外的服务器负荷
 * 逃逸口（跳转到其他站点时容易丢失信息）
 * 在会话间是非持久的（除非收藏了`URL`，否则下次打开时信息已丢失）

######`cookie`

* `cookie`的类型
 * 会话`cookie`（临时，退出浏览器就被删除）
 * 持久`cookie`（存储在硬盘上，有过期时间）
* `cookie`是如何工作的
 * `cookie`中包含了一组（`name = value`）的值
 * 通过`Set-Cookie`或`Set-Cookie2`首部发送给服务器
* 不同站点使用不同的`cookie`
 * `cookie`的域属性（针对某站点使用）
 * `cookie`的路径属性（针对某路径使用）
* `cookie`缓存的指导性规则
 * 如果无法缓存文档，要将其标识出来（除了`Set-Cookie`首部可缓存：`Cache-Control:no-cache="Set-Cookie"`，或对可缓存的文档：`Cache-Control:public`）
 * 缓存`Set-Cookie`首部时要小心（使用`Cache-Control:must-revalidate,max-age=0`来强制缓存与原始服务器重新验证每条请求，并将`Set-Cookie`首部合并到客户端响应中）
 * 小心处理带有`cookie`首部的请求（缓存带有`cookie`首部的图片，过期时间设为零，强制每次都进行再验证）

#####第12章 基本认证机制
######认证协议与首部

* 质询：`www-Authenticate`（没有认证信息 请求方法`GET` 返回`401 Unauthorized`）
* 授权：`Authorization`（重新发送并带有`Authorization`首部 请求方法`Get`）
* 成功：`Authentication-Info`（如果授权证书正确则正常返回 `200 OK`）

######基本认证

* 请求资源
* 回送`401 Authorization Required`，同时回送`www-Authenticate`
* 弹出对话框，请求输入用户名密码
* 将用户名密码用冒号连接起来，并用`Base64`转换，然后放入`Authorization`首部回送
* 服务器解码，验证是否正确，返回`HTTP 200 OK`

######代理认证首部

* `Unauthorized status code : 407`（此项说明返回码不同，正常为401）
* `Proxy-Authenticate`
* `Proxy-Authorization`
* `Proxy-Authentication-Info`

######基本认证的安全缺陷

* 密码明文传输
* 用户名密码被截获，用于重复请求此接口或其他接口
* 用户名密码被截获，被撞库攻击其他网站
* 容易被钓鱼服务器骗取用户名密码

#####第13章 摘要认证
######摘要认证的改进

* 永远不会以明文方式在网络上发送密码
* 可以防止恶意用户捕获并重新认证的握手过程
* 可以有选择的防止对报文内容的篡改
* 防范其他几种常见的攻击方式

######摘要认证的握手机制

* 服务器计算出一个随机数
* 服务器将这个随机数放在`WWW-Authenticate`质询报文中，与服务器所支持的算法列表一同发往客户端
* 客户端选择一个算法，计算出密码和其他数据的摘要
* 客户端将摘要放在一条`Authorization`报文中发回服务器，如果客户端要对服务器进行认证，可以发送客户端随机数
* 服务器接收摘要、选中的算法以及支撑数据，计算出与客户端相同的摘要。然后服务器将本地生成的摘要与网络传送过来的摘要进行比较，验证其是否匹配。如果客户端反过来用客户端随机数来对服务器进行质询，就会创建客户端摘要。服务器可以预先将下一个随机数计算出来，提前将其传递给客户端，这样下一次客户端就可以预先发送正确的摘要了

######摘要的计算

* 摘要算法的三个组件（`H`和`KD`处理两块数据`A1`和`A2`，产生摘要）
 * 由单项散列函数`H(d)`和摘要`KD(s,d)`组成的一对函数，其中`s`表示密码，`d`表示数据
 * 一个包含了安全信息的数据块，包括密码，成为`A1`
 * 一个包含了请求报文中非保密属性的数据块，成为`A2`
* 算法`H(d)`和`KD(s,d)`
 * `RFC 2617`建议的两种算法为`MD5`和`MD5-sess`（`sess`表示会话）
 * 如果没有指定其他算法，默认算法为`MD5`
 * `MD5`和`MD5-sess`都会用函数`H`来计算数据的`MD5`，用摘要函数`KD`来计算以冒号链接的密码和非保密数据的`MD5`
* 与安全性相关的数据（`A1`）
 * 包含用户名、密码、保护域、随机数等内容，只涉及安全信息，与报文内容自身无关
 * `A1`会与`H`、`KD`和`A2`一同用于摘要计算
* 与报文有关的数据（`A2`）
 * 表示的是与报文自身有关的信息，比如`URL`、请求方法和报文实体的主体部分
 * `A2`会与`H`、`KD`和`A1`一同用于摘要计算
 * 第一种策略：当`qop="auth"`时，只包含`HTTP`请求方法和`URL`
 * 第二种策略：当`qop="auth-int"`时，添加报文实体的主体部分，以提供一定程度的报文完整性检测
* 摘要算法总述
 * 第一种方式要与老规范`RFC 2069`兼容，在没有`qop`选项的时候使用。它是用保密信息和随机报文数据的散列值来计算摘要的
 * 第二种方式是现在推荐使用的方式——这种方式包含了对随机数计算和对称认证的支持。只要`qop`为`auth`或`auth-int`，就要使用这种方式。它向摘要中添加了随机计数、`qop`和`cnonce`数据

######预授权方式

* 服务器预先在`Authentication-Info`成功首部中发送下一个随机数
* 服务器允许在一小段时间内使用同一个随机数
* 客户端和服务器使用同步的、可预测的随机数生成算法

#####第14章 安全`HTTP`
######安全`HTTP`技术期望的功能

* 服务器认证（客户端知道它们是在于真正的服务器通话）
* 客户端认证（服务器知道它们是在于真正的客户端通话）
* 完整性（客户端和服务器的数据不会被修改）
* 加密（客户端和服务器的对话是私密的，无须担心被窃听）
* 效率（一个运行的足够快的算法，以便低端的客户端和服务器使用）
* 普适性（基本上所有的客户端和服务器都支持这些协议）
* 管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）
* 适应性（能够支持当前最知名的安全方法）
* 在社会上的可行性（满足社会的政治文化需要）

####第四部分 实体、编码与国际化
#####第15章 实体与编码
######

#####第16章 国际化
######

#####第17章 内容协商与转码
######

####第五部分 内容发布与分发
#####第18章 `Web`主机托管
######

#####第19章 发布系统
######

#####第20章 重定向与负载均衡
######

#####第21章 日志记录与使用情况跟踪
######
